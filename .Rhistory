for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// Boost seems much
// [[Rcpp::depends(BH)]]
#include <string_view>
#define BOOST_NO_AUTO_PTR
#include <boost/regex.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/iterator/transform_iterator.hpp>
#undef BOOST_NO_AUTO_PTR
using namespace std;
using namespace std::experimental;
using namespace boost;
string_view stringfier(const cregex_token_iterator::value_type &match) {
return {match.first, static_cast<size_t>(match.length())};
}
using string_view_iterator =
transform_iterator<decltype(&stringfier), cregex_token_iterator>;
iterator_range<string_view_iterator> split(string& s, const regex &r) {
return {
string_view_iterator(
cregex_token_iterator(s.begin(), s.end(), r, -1),
stringfier
),
string_view_iterator()
};
}
// [[Rcpp::export(rng=false)]]
vector<string> test(){
const regex r(" +");
vector<string> v;
v.reserve(10);
copy(split("a b c", r), back_inserter(v));
return v;
}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <iostream>
#include <iterator>
#include <string>
#include <regex>
#include <vector>
// [[Rcpp::plugins("cpp2a")]]
// [[(Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl(const SEXP& charVec, const std::string& pattern){
if(TYPEOF(charVec) != STRSXP)
Rcpp::stop("charVec must be a character vector");
std::regex re(pattern);
R_xlen_t n = Rf_xlength(charVec);
Rcpp::LogicalVector res(n);
SEXP* xPtr = STRING_PTR(charVec);
for(R_xlen_t i = 0; i < n; i++, xPtr++){
if(std::regex_search(CHAR(*xPtr), re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// [[Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl2(const std::vector<std::string>& charVec,
const std::string& pattern){
std::regex re(pattern);
R_xlen_t n = charVec.size();
Rcpp::LogicalVector res(n);
auto b = charVec.begin();
for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// Boost seems much
// [[Rcpp::depends(BH)]]
#include <string_view>
//#define BOOST_NO_AUTO_PTR
#include <boost/regex.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/iterator/transform_iterator.hpp>
//#undef BOOST_NO_AUTO_PTR
using namespace std;
using namespace std::experimental;
using namespace boost;
string_view stringfier(const cregex_token_iterator::value_type &match) {
return {match.first, static_cast<size_t>(match.length())};
}
using string_view_iterator =
transform_iterator<decltype(&stringfier), cregex_token_iterator>;
iterator_range<string_view_iterator> split(string& s, const regex &r) {
return {
string_view_iterator(
cregex_token_iterator(s.begin(), s.end(), r, -1),
stringfier
),
string_view_iterator()
};
}
// [[Rcpp::export(rng=false)]]
vector<string> test(){
const regex r(" +");
vector<string> v;
v.reserve(10);
copy(split("a b c", r), back_inserter(v));
return v;
}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <iostream>
#include <iterator>
#include <string>
#include <regex>
#include <vector>
// [[Rcpp::plugins("cpp2a")]]
// [[(Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl(const SEXP& charVec, const std::string& pattern){
if(TYPEOF(charVec) != STRSXP)
Rcpp::stop("charVec must be a character vector");
std::regex re(pattern);
R_xlen_t n = Rf_xlength(charVec);
Rcpp::LogicalVector res(n);
SEXP* xPtr = STRING_PTR(charVec);
for(R_xlen_t i = 0; i < n; i++, xPtr++){
if(std::regex_search(CHAR(*xPtr), re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// [[Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl2(const std::vector<std::string>& charVec,
const std::string& pattern){
std::regex re(pattern);
R_xlen_t n = charVec.size();
Rcpp::LogicalVector res(n);
auto b = charVec.begin();
for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// Boost seems much
// [[Rcpp::depends(BH)]]
#include <string_view>
#define BOOST_NO_AUTO_PTR
#include <boost/regex.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/iterator/transform_iterator.hpp>
#undef BOOST_NO_AUTO_PTR
using namespace std;
using namespace std::experimental;
using namespace boost;
string_view stringfier(const cregex_token_iterator::value_type &match) {
return {match.first, static_cast<size_t>(match.length())};
}
using string_view_iterator =
transform_iterator<decltype(&stringfier), cregex_token_iterator>;
iterator_range<string_view_iterator> split(string& s, const regex &r) {
return {
string_view_iterator(
cregex_token_iterator(s.begin(), s.end(), r, -1),
stringfier
),
string_view_iterator()
};
}
// [[Rcpp::export(rng=false)]]
vector<string> test(){
const regex r(" +");
vector<string> v;
v.reserve(10);
copy(split("a b c", r), back_inserter(v));
return v;
}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <iostream>
#include <iterator>
#include <string>
#include <regex>
#include <vector>
// [[Rcpp::plugins("cpp2a")]]
// [[(Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl(const SEXP& charVec, const std::string& pattern){
if(TYPEOF(charVec) != STRSXP)
Rcpp::stop("charVec must be a character vector");
std::regex re(pattern);
R_xlen_t n = Rf_xlength(charVec);
Rcpp::LogicalVector res(n);
SEXP* xPtr = STRING_PTR(charVec);
for(R_xlen_t i = 0; i < n; i++, xPtr++){
if(std::regex_search(CHAR(*xPtr), re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// [[Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl2(const std::vector<std::string>& charVec,
const std::string& pattern){
std::regex re(pattern);
R_xlen_t n = charVec.size();
Rcpp::LogicalVector res(n);
auto b = charVec.begin();
for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// Boost seems much
// [[Rcpp::depends(BH)]]
#include <string_view>
//#define BOOST_NO_AUTO_PTR
#include <boost/regex.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/iterator/transform_iterator.hpp>
//#undef BOOST_NO_AUTO_PTR
using namespace std;
using namespace std::experimental;
using namespace boost;
string_view stringfier(const cregex_token_iterator::value_type &match) {
return {match.first, static_cast<size_t>(match.length())};
}
using string_view_iterator =
transform_iterator<decltype(&stringfier), cregex_token_iterator>;
iterator_range<string_view_iterator> split(string& s, const regex &r) {
return {
string_view_iterator(
cregex_token_iterator(s.begin(), s.end(), r, -1),
stringfier
),
string_view_iterator()
};
}
// [[Rcpp::export(rng=false)]]
vector<string> test(){
const regex r(" +");
vector<string> v;
v.reserve(10);
copy(split("a b c", r), back_inserter(v));
return v;
}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <iostream>
#include <iterator>
#include <string>
#include <regex>
#include <vector>
// [[Rcpp::plugins("cpp2a")]]
// [[(Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl(const SEXP& charVec, const std::string& pattern){
if(TYPEOF(charVec) != STRSXP)
Rcpp::stop("charVec must be a character vector");
std::regex re(pattern);
R_xlen_t n = Rf_xlength(charVec);
Rcpp::LogicalVector res(n);
SEXP* xPtr = STRING_PTR(charVec);
for(R_xlen_t i = 0; i < n; i++, xPtr++){
if(std::regex_search(CHAR(*xPtr), re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// [[Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl2(const std::vector<std::string>& charVec,
const std::string& pattern){
std::regex re(pattern);
R_xlen_t n = charVec.size();
Rcpp::LogicalVector res(n);
auto b = charVec.begin();
for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// Boost seems much
// [[Rcpp::depends(BH)]]
#include <string_view>
#define BOOST_NO_AUTO_PTR
#include <boost/regex.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/iterator/transform_iterator.hpp>
#undef BOOST_NO_AUTO_PTR
using namespace std;
using namespace boost;
string_view stringfier(const cregex_token_iterator::value_type &match) {
return {match.first, static_cast<size_t>(match.length())};
}
using string_view_iterator =
transform_iterator<decltype(&stringfier), cregex_token_iterator>;
iterator_range<string_view_iterator> split(string& s, const regex &r) {
return {
string_view_iterator(
cregex_token_iterator(s.begin(), s.end(), r, -1),
stringfier
),
string_view_iterator()
};
}
// [[Rcpp::export(rng=false)]]
vector<string> test(){
const regex r(" +");
vector<string> v;
v.reserve(10);
copy(split("a b c", r), back_inserter(v));
return v;
}
')
# Simple case no weirdness
case1 <-
list(args = c('-f', '--fool', 'abc', 'dfd', 'cc', '--good', 'ad', '3', '4', '--fool', '44', '-h'),
flags = c('-', '--'))
# Other case, weird flags supplied
case2 <-
list(args = c('@f', '@@fool', 'abc', 'dfd', 'cc', '-g', 'ad', '3', '4', '--fool', '44', '/h'),
flags = c('@', '@@', '-', '/', '--'))
XPtr1 <- test_initializer(case1[['args']], case1[['flags']])
Rcpp::sourceCpp("cpp/locator.cpp")
setwd('inst/tinytest')
Rcpp::sourceCpp("cpp/locator.cpp")
XPtr1 <- test_initializer(case1[['args']], case1[['flags']])
XPtr2 <- test_initializer(case2[['args']], case2[['flags']])
XPtr1
XPtr2
test_get(XPtr, 'fool')
test_get(XPtr1, 'fool')
test_get(XPtr1, '--fool')
test_get(XPtr2, '--fool')
test_get(XPtr2, '@@fool')
test_get(XPtr1, '--fool')
expect_identical(test_get(XPtr1, '--fool'), list(list('abc', 'dfd', 'cc'), list('44')))
library(tinytest)
expect_identical(test_get(XPtr1, '--fool'), list(list('abc', 'dfd', 'cc'), list('44')))
test_get(XPtr1, '--fool')
list(list('abc', 'dfd', 'cc'), list('44'))
expect_identical(test_get(XPtr1, '--fool'), list(c('abc', 'dfd', 'cc'), c('44')))
test_get(XPtr2, '@@fool')
expect_identical(test_get(XPtr2, '@@fool'), list(c('abc', 'dfd', 'cc')))
test_contains(XPtr1, '--fool')
expect_identical(test_get(XPtr1, '--ds'), list())
expect_identical(test_get(XPtr2, '/ds'), list())
expect_true(test_contains(XPtr1, '--fool'))
expect_true(test_contains(XPtr1, '--good'))
test_get(XPtr1, '-g')
test_get(XPtr2, '-g')
expect_true(test_contains(XPtr2, '-g'))
expect_identical(test_pop(XPtr2, '-g'), list(c('ad', '3', '4')))
expect_false(test_contains(XPtr2, '-g'))
# Other case, weird flags supplied
case2 <-
list(args = c('@f', '@@fool', 'abc', 'dfd', 'cc', '-g', 'ad', '3', '4', '--fool', '44', '/h'),
flags = c('@', '@@', '-', '/', '--'))
XPtr2 <- test_initializer(case2[['args']], case2[['flags']])
identical(test_get(XPtr2, '-g'), list(c('ad', '3', '4')))
expect_identical(test_pop(XPtr2, '-g'), list(c('ad', '3', '4')))
# Other case, weird flags supplied
case2 <-
list(args = c('@f', '@@fool', 'abc', 'dfd', 'cc', '-g', 'ad', '3', '4', '--fool', '44', '/h'),
flags = c('@', '@@', '-', '/', '--'))
XPtr2 <- test_initializer(case2[['args']], case2[['flags']])
test_pop(XPtr2, '-g')
test_iterate(XPtr2)
list('h', list(list(character())))
test_iterate(XPtr2)[[1]]
list(list('h'), list(list(character())))
test_iterate(XPtr2)[[2]]
test_iterate(XPtr2)[[3]]
test_iterate(XPtr2)[[4]]
test_iterate(XPtr2)[[5]]
expect_identical(test_iterate(XPtr2),
list(list(list('h'), list(list(character()))),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
v <- test_iterate(XPtr2)
v
list(list(list('h'), list(list(character()))),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc'))))
expect_identical(test_iterate(XPtr2),
list(list('h',list(list(character()))),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
test_iterate(XPtr2)
list(list('h',list(list(character()))),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc'))))
expect_identical(test_iterate(XPtr2),
list(list('h',list(character())),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
test_iterate(XPtr2)
list(list('h',list(character())),
list('@f', list()),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc'))))
expect_identical(test_iterate(XPtr2),
list(list('h',list(character())),
list('@f', list(character())),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
test_iterate(XPtr2)
list(list('h',list(character())),
list('@f', list(character())),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc'))))
expect_identical(test_iterate(XPtr2),
list(list('h',list(character())),
list('@f', list(character())),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
test_iterate(XPtr2)
expect_identical(test_iterate(XPtr2),
list(list('/h',list(character())),
list('@f', list(character())),
list('--fool', list('44')),
list('@@fool', list(c('abc', 'dfd', 'cc')))))
test_iterate(XPtr1)
expect_identical(test_iterate(XPtr1),
list(list('-h',list(character())),
list('--good', list(c('ad', '3', '4'))),
list('-f', list(character())),
list('--fool', list(c('abc', 'dfd', 'cc'), c('44')))))
sourceCpp(code =
'
#include <Rcpp.h>
#include <iostream>
#include <iterator>
#include <string>
#include <regex>
#include <vector>
// [[Rcpp::plugins("cpp2a")]]
// [[(Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl(const SEXP& charVec, const std::string& pattern){
if(TYPEOF(charVec) != STRSXP)
Rcpp::stop("charVec must be a character vector");
std::regex re(pattern);
R_xlen_t n = Rf_xlength(charVec);
Rcpp::LogicalVector res(n);
SEXP* xPtr = STRING_PTR(charVec);
for(R_xlen_t i = 0; i < n; i++, xPtr++){
if(std::regex_search(CHAR(*xPtr), re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
// [[Rcpp::export(rng=false)]]
Rcpp::LogicalVector Rcpp_grepl2(const std::vector<std::string>& charVec,
const std::string& pattern){
std::regex re(pattern);
R_xlen_t n = charVec.size();
Rcpp::LogicalVector res(n);
auto b = charVec.begin();
for(R_xlen_t i = 0; i < n; i++, b++){
if(std::regex_search(*b, re))
res[i] = TRUE;
else
res[i] = FALSE;
}
return res;
}
#include <string_view>
// [[Rcpp::export]]
void test(std::string x){
std::string_view ss(x);
Rcpp::Rcout << ss << std::endl;
}
')
test('abc')
# case with positionals
case3 <-
list(args = c('a', 'c', 'b', '-f', '--fool', 'abc', 'dfd', 'cc', '--good', 'ad', '3', '4', '--fool', '44', '-h'),
flags = c('-', '--'))
XPtr3 <- test_initializer(case3[['args']], case3[['flags']])
test_get(XPtr3, 'positionals')
expect_identical(test_get(XPtr3, 'positionals'), list(c('a', 'b', 'c')))
expect_identical(test_get(XPtr3, 'positionals'), list(c('a', 'c', 'b')))
