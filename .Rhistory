}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <list>
#include <vector>
#include <string>
using namespace Rcpp;
using namespace std;
template<typename T>
inline bool same_lengths(const T& x){
return same_lengths(wrap(x));
}
template<typename T>
inline bool same_lengths(const std::list<T>& x){
if(x.size() <= 1)
return true;
auto b = x.begin(), e = x.end();
auto n = b -> size();
b++;
for(;b != e; b++){
if((b -> size()) != n)
return false;
}
return true;
}
template<>
inline bool same_lengths(const SEXP& x){
auto type = TYPEOF(x);
if(type == VECSXP){
R_xlen_t size = Rf_xlength(x);
if(size <= 1)
return true;
R_xlen_t n = Rf_xlength(VECTOR_ELT(x, 0));
for(R_xlen_t i = 1; i < size; i++){
if(Rf_xlength(VECTOR_ELT(x, i)) != n)
return false;
}
}else if(type == LISTSXP)
stop("Lengths not defined for pairlists");
return true;
}
// [[Rcpp::export]]
inline bool all_equal_length(const SEXP& x){
List xx(x);
std::list<std::list<int>> xxx = as<std::list<std::list<int>>>(x);
Rcout << same_lengths(xx) << " " << same_lengths(x) << " " << same_lengths(xxx) << "\\n";
return wrap(R_NilValue);
}
// [[Rcpp::export]]
inline SEXP matchRcpp(const CharacterVector& x,  const CharacterVector& table){
return Rcpp::match(x, table);
}
// [[Rcpp::export]]
inline SEXP liist1(const SEXP& x){
List xx(x);
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist2(const SEXP& x){
List xx = x;
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist3(const SEXP& x){
List xx = as<List>(x);
return wrap(xx);
}
static const CharacterVector fields = {"name",
"narg",
"meta",
"action",
"rawPassingOption",
"rawIngestionOption",
"helpFlags",
"flags",
"choices",
"parseFun",
"help",
"defaultVal",
"constVal",
"required"};
typedef Rcpp::sugar::IndexHash<STRSXP> strHASH;
// [[Rcpp::export]]
inline SEXP hashTest(const SEXP& x, const SEXP& y){
SEXP names = Rf_getAttrib(x, R_NamesSymbol);
CharacterVector fields2 = Rf_getAttrib(y, R_NamesSymbol);
strHASH hashTable(names);
hashTable.fill();
LogicalVector fieldsInNames2(fields2.begin(),
fields2.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
LogicalVector fieldsInNames(fields.begin(),
fields.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
IntegerVector o = hashTable.lookup(fields.get_ref());
return wrap(fieldsInNames);
}
class addressBook {
public:
string name = "Joe";
double phone = 5555;
addressBook(const addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(){}
};
// [[Rcpp::export]]
inline SEXP classref(){
vector<addressBook> bar;
addressBook x;
bar.push_back( x );
return wrap(R_NilValue);
}
// [[Rcpp::plugins(cpp17)]]
inline SEXP svtest(SEXP x){
string_view xx = as<string_view>(x);
Rcout << xx << "\\n";
return wrap(R_NilValue);
}
')
sourceCpp(code =
'
#include <Rcpp.h>
#include <list>
#include <vector>
#include <string>
using namespace Rcpp;
using namespace std;
template<typename T>
inline bool same_lengths(const T& x){
return same_lengths(wrap(x));
}
template<typename T>
inline bool same_lengths(const std::list<T>& x){
if(x.size() <= 1)
return true;
auto b = x.begin(), e = x.end();
auto n = b -> size();
b++;
for(;b != e; b++){
if((b -> size()) != n)
return false;
}
return true;
}
template<>
inline bool same_lengths(const SEXP& x){
auto type = TYPEOF(x);
if(type == VECSXP){
R_xlen_t size = Rf_xlength(x);
if(size <= 1)
return true;
R_xlen_t n = Rf_xlength(VECTOR_ELT(x, 0));
for(R_xlen_t i = 1; i < size; i++){
if(Rf_xlength(VECTOR_ELT(x, i)) != n)
return false;
}
}else if(type == LISTSXP)
stop("Lengths not defined for pairlists");
return true;
}
// [[Rcpp::export]]
inline bool all_equal_length(const SEXP& x){
List xx(x);
std::list<std::list<int>> xxx = as<std::list<std::list<int>>>(x);
Rcout << same_lengths(xx) << " " << same_lengths(x) << " " << same_lengths(xxx) << "\\n";
return wrap(R_NilValue);
}
// [[Rcpp::export]]
inline SEXP matchRcpp(const CharacterVector& x,  const CharacterVector& table){
return Rcpp::match(x, table);
}
// [[Rcpp::export]]
inline SEXP liist1(const SEXP& x){
List xx(x);
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist2(const SEXP& x){
List xx = x;
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist3(const SEXP& x){
List xx = as<List>(x);
return wrap(xx);
}
static const CharacterVector fields = {"name",
"narg",
"meta",
"action",
"rawPassingOption",
"rawIngestionOption",
"helpFlags",
"flags",
"choices",
"parseFun",
"help",
"defaultVal",
"constVal",
"required"};
typedef Rcpp::sugar::IndexHash<STRSXP> strHASH;
// [[Rcpp::export]]
inline SEXP hashTest(const SEXP& x, const SEXP& y){
SEXP names = Rf_getAttrib(x, R_NamesSymbol);
CharacterVector fields2 = Rf_getAttrib(y, R_NamesSymbol);
strHASH hashTable(names);
hashTable.fill();
LogicalVector fieldsInNames2(fields2.begin(),
fields2.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
LogicalVector fieldsInNames(fields.begin(),
fields.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
IntegerVector o = hashTable.lookup(fields.get_ref());
return wrap(fieldsInNames);
}
class addressBook {
public:
string name = "Joe";
double phone = 5555;
addressBook(const addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(){}
};
// [[Rcpp::export]]
inline SEXP classref(){
vector<addressBook> bar;
addressBook x;
bar.push_back( x );
return wrap(R_NilValue);
}
// [[Rcpp::plugins(cpp17)]]
inline SEXP svtest(SEXP x){
string_view xx = "as<string_view>(x)";
Rcout << xx << "\\n";
return wrap(R_NilValue);
}
')
svtest("abc")
sourceCpp(code =
'
#include <Rcpp.h>
#include <list>
#include <vector>
#include <string>
using namespace Rcpp;
using namespace std;
template<typename T>
inline bool same_lengths(const T& x){
return same_lengths(wrap(x));
}
template<typename T>
inline bool same_lengths(const std::list<T>& x){
if(x.size() <= 1)
return true;
auto b = x.begin(), e = x.end();
auto n = b -> size();
b++;
for(;b != e; b++){
if((b -> size()) != n)
return false;
}
return true;
}
template<>
inline bool same_lengths(const SEXP& x){
auto type = TYPEOF(x);
if(type == VECSXP){
R_xlen_t size = Rf_xlength(x);
if(size <= 1)
return true;
R_xlen_t n = Rf_xlength(VECTOR_ELT(x, 0));
for(R_xlen_t i = 1; i < size; i++){
if(Rf_xlength(VECTOR_ELT(x, i)) != n)
return false;
}
}else if(type == LISTSXP)
stop("Lengths not defined for pairlists");
return true;
}
// [[Rcpp::export]]
inline bool all_equal_length(const SEXP& x){
List xx(x);
std::list<std::list<int>> xxx = as<std::list<std::list<int>>>(x);
Rcout << same_lengths(xx) << " " << same_lengths(x) << " " << same_lengths(xxx) << "\\n";
return wrap(R_NilValue);
}
// [[Rcpp::export]]
inline SEXP matchRcpp(const CharacterVector& x,  const CharacterVector& table){
return Rcpp::match(x, table);
}
// [[Rcpp::export]]
inline SEXP liist1(const SEXP& x){
List xx(x);
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist2(const SEXP& x){
List xx = x;
return wrap(xx);
}
// [[Rcpp::export]]
inline SEXP liist3(const SEXP& x){
List xx = as<List>(x);
return wrap(xx);
}
static const CharacterVector fields = {"name",
"narg",
"meta",
"action",
"rawPassingOption",
"rawIngestionOption",
"helpFlags",
"flags",
"choices",
"parseFun",
"help",
"defaultVal",
"constVal",
"required"};
typedef Rcpp::sugar::IndexHash<STRSXP> strHASH;
// [[Rcpp::export]]
inline SEXP hashTest(const SEXP& x, const SEXP& y){
SEXP names = Rf_getAttrib(x, R_NamesSymbol);
CharacterVector fields2 = Rf_getAttrib(y, R_NamesSymbol);
strHASH hashTable(names);
hashTable.fill();
LogicalVector fieldsInNames2(fields2.begin(),
fields2.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
LogicalVector fieldsInNames(fields.begin(),
fields.end(),
Rcpp::sugar::InSet<strHASH>(hashTable));
IntegerVector o = hashTable.lookup(fields.get_ref());
return wrap(fieldsInNames);
}
class addressBook {
public:
string name = "Joe";
double phone = 5555;
addressBook(const addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(addressBook& x) : name(x.name), phone(x.phone) {}
addressBook(){}
};
// [[Rcpp::export]]
inline SEXP classref(){
vector<addressBook> bar;
addressBook x;
bar.push_back( x );
return wrap(R_NilValue);
}
// [[Rcpp::plugins(cpp17)]]
// [[Rcpp::export]]
inline SEXP svtest(SEXP x){
string_view xx = as<string>(x);
Rcout << xx << "\\n";
return wrap(R_NilValue);
}
')
svtest("abc")
svtest("abc i am good")
?assign
assign(x)
i <- 1
assign(i)
assign(i) -> 2
2 -> paste("a")
2 -> "a"
library(ggplot2)
?element_text
plot <- ggplot(mpg, aes(displ, hwy)) + geom_point()
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
)
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
),
)
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
), axis.text.x = element_text(color = rep('blue', 6))
)
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
), axis.text.x = element_text(color = c(rep('blue', 5), 'red'))
)
colour <- c("2" = 'red', "4" = 'red', "5" = 'red', '3' = 'blue', '6' = 'blue', '7' = "yellow")
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
), axis.text.x = element_text(color = colours)
)
colous
colours
plot + theme(
panel.background = element_rect(fill = "white"),
plot.margin = margin(2, 2, 2, 2, "cm"),
plot.background = element_rect(
fill = "grey90",
colour = "black",
size = 1
), axis.text.x = element_text(color = colour)
)
df<-structure(list(time = c("04:00", "04:15", "04:30", "04:45", "05:00",
"05:15", "05:30", "05:45", "06:00", "06:15", "06:30", "06:45",
"07:00", "07:15", "07:30", "07:45", "08:00", "08:15", "08:30",
"08:45", "09:00", "09:15", "09:30", "09:45", "10:00", "10:15",
"10:30", "10:45", "11:00", "11:15", "11:30", "11:45", "12:00",
"12:15", "12:30", "12:45", "13:00", "13:15", "13:30", "13:45",
"14:00", "14:15", "14:30", "14:45", "15:00", "15:15", "15:30",
"15:45", "16:00", "16:15", "16:30", "16:45", "17:00", "17:15",
"17:30", "17:45", "18:00", "18:15", "18:30", "18:45", "19:00",
"19:15", "19:30", "19:45", "20:00", "20:15", "20:30", "20:45",
"21:00", "21:15", "21:30", "21:45", "22:00", "22:15", "22:30",
"22:45", "23:00", "23:15", "23:30", "23:45", "00:00", "00:15",
"00:30", "00:45", "01:00", "01:15", "01:30", "01:45", "02:00",
"02:15", "02:30", "02:45", "03:00", "03:15", "03:30", "03:45"
), index = 1:96, variable = structure(c(1L, 1L, 1L, 1L, 1L, 1L,
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), .Label = "value", class = "factor"),
value = c(0, 0.00120336943441637, 0.00401123144805455, 0.00481347773766546,
0.0116325711993582, 0.0104292017649418, 0.0236662655435219,
0.0284797432811873, 0.0709987966305656, 0.0770156438026474,
0.0882470918572002, 0.0918572001604493, 0.201363818692339,
0.219013237063779, 0.281989570798235, 0.298435619735259,
0.503409546730846, 0.555956678700361, 0.67428800641797, 0.707180104292018,
0.8896911351785, 0.922583233052547, 0.935018050541516, 0.936221419975933,
0.963096670677898, 0.974729241877256, 0.985960689931809,
0.984757320497393, 0.984757320497393, 0.994785399117529,
1, 0.997994384275973, 0.919775371038909, 0.902527075812274,
0.860409145607702, 0.854793421580425, 0.756117127958283,
0.768953068592058, 0.837545126353791, 0.847172081829122,
0.944243882872042, 0.963497793822704, 0.965503409546731,
0.967107902125953, 0.957079823505816, 0.969915764139591,
0.9558764540714, 0.953469715202567, 0.890894504612916, 0.882872041716807,
0.8235058162856, 0.805054151624549, 0.661452065784196, 0.631768953068592,
0.549538708383474, 0.51544324107501, 0.300842358604091, 0.277978339350181,
0.235058162855997, 0.214199759326113, 0.143602085840353,
0.139590854392298, 0.129161652627357, 0.127557160048135,
0.0946650621740874, 0.0934616927396711, 0.0886482150020056,
0.0834336141195347, 0.0709987966305656, 0.0722021660649819,
0.0705976734857601, 0.0701965503409547, 0.0605695948656237,
0.0605695948656237, 0.0573606097071801, 0.0561572402727637,
0.0389089450461292, 0.036101083032491, 0.0344965904532692,
0.0348977135980746, 0.0260730044123546, 0.0280786201363819,
0.0260730044123546, 0.0260730044123546, 0.0212595266746891,
0.0208584035298837, 0.0164460489370237, 0.0156438026474128,
0.00922583233052547, 0.00882470918572002, 0.00842358604091456,
0.00882470918572002, 0.00240673886883273, 0.00200561572402728,
0.00200561572402728, 0.00200561572402728)), class = "data.frame", row.names = c(NA,
-96L))
df
head(df)
one <- which(x %in% c("08:00", "15:00", "18:30"))
two <- which(x %in% c("07:00", "15:30", "19:00", "21:00"))
f <- function(x){
d <- rep('black', NROW(x))
one <- which(x %in% c("08:00", "15:00", "18:30"))
two <- which(x %in% c("07:00", "15:30", "19:00", "21:00"))
d[one] <- '#FF9999'
d[two] <- '#0000FF'
d
}
head(df)
df$colour <-
ggplot2(df, aes(x = time, y = value)) +
geom_point() +
theme(axis.text.x = element_text(col = df$colour))
df$colour <-
ggplot(df, aes(x = time, y = value)) +
geom_point() +
theme(axis.text.x = element_text(col = df$colour))
df$colour <-
ggplot(df, aes(x = time, y = value)) +
geom_point() +
theme(axis.text.x = element_text(color = df$colour))
df$colour <- f(df$time)
ggplot(df, aes(x = time, y = value)) +
geom_point() +
theme(axis.text.x = element_text(color = df$colour))
ggplot(df, aes(x = time, y = value)) +
geom_point() +
theme(axis.text.x = element_text(color = df$colour,
angle = 90))
df$time
sort(df$time)
