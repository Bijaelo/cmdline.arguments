for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans.push_back(Rf_length(x[i]));
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const Rcpp::List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
Rcpp_lengths(ll)
rm(list=ls())
library(Rcpp)
library(microbenchmark)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans.push_back(Rf_length(x[i]));
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const Rcpp::List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
ll <- lapply(1:1e4, function(n) sample(letters, n, TRUE))
lengths(ll)
Rc_lengths(ll)
Rcpp_lengths(ll)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
int n_elements = Rf_length(x[i]);
ans.push_back(n_elements);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const Rcpp::List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
Rcpp_lengths(ll)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
IntegerVector ans(n)
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
int n_elements = Rf_length(x[i]);
ans[i] = n_elements;
//ans.push_back(n_elements);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
Rcpp_lengths(ll)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
IntegerVector ans(n);
//std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
int n_elements = Rf_length(x[i]);
ans[i] = n_elements;
//ans.push_back(n_elements);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
Rcpp_lengths(ll)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans[i] = Rf_xlength(x[i]);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
int n_elements = Rf_length( lst[i] );
res[i] = n_elements;
}
return res;
}
")
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans[i] = Rf_xlength(x[i]);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
res[i] = Rf_length( lst[i] );
}
return res;
}
")
microbenchmark(R = lengths(ll),
Rc = Rc_lengths(ll),
Rcpp = Rcpp_lengths(ll),
rcpp = rcpp_lengths(ll))
microbenchmark(R = lengths(ll),
Rc = Rc_lengths(ll),
Rcpp = Rcpp_lengths(ll),
rcpp = rcpp_lengths_works(ll))
microbenchmark(R = lengths(ll),
Rc = Rc_lengths(ll),
Rcpp = Rcpp_lengths(ll),
rcpp = rcpp_lengths_works(ll), times = 1e4)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans[i] = Rf_xlength(x[i]);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
res[i] = Rf_length( lst[i] );
}
return res;
}
")
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans[i] = Rf_xlength(x[i]);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();  ss
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
res[i] = Rf_length( lst[i] );
}
return res;
}
")
?as.complex
0i ^ (-3:3)
matrix(1i^ (-6:5), nrow = 4)
# The Arg(.) is an angle:
zz <- (rep(1:4, len = 9) + 1i*(9:1))/10
zz.shift <- complex(modulus = Mod(zz), argument = Arg(zz) + pi)
plot(zz, xlim = c(-1,1), ylim = c(-1,1), col = "red", asp = 1,
main = expression(paste("Rotation by "," ", pi == 180^o)))
abline(h = 0, v = 0, col = "blue", lty = 3)
points(zz.shift, col = "orange")
as.complex("2+1i")
as.complex("2-1i")
as.complex("2-1i")**2
2-1i
(2-1i)**2
all_equal_length <- function(x)diff(range(lengths(x))) == 0
all_equal_length <- function(x)diff(range(lengths(x)))
all_equal_length(ll)
1 - 1e4
diff(1, 1e4)
diff(c(1, 1e4))
diff(c(1e4, 1))
sample(10)
sample(1:10)
sample(1:10, 1)
microbenchmark(R = lengths(ll),
Rc = Rc_lengths(ll),
Rcpp = Rcpp_lengths(ll),
rcpp = rcpp_lengths_works(ll), times = 1e4)
sourceCpp(code =
"
#include <Rcpp.h>
#include <vector>
using namespace Rcpp;
// [[Rcpp::export]]
SEXP Rc_lengths(const SEXP& x){
R_xlen_t n = Rf_length(x);
SEXP ans = PROTECT(Rf_allocVector(INTSXP, n));
int *ptr = INTEGER(ans);
for(auto i = 0; i < n; i++, ptr++){
*ptr = Rf_xlength(VECTOR_ELT(x, i));
}
UNPROTECT(1);
return ans;
}
// [[Rcpp::export]]
SEXP Rcpp_lengths(const List& x){
R_xlen_t n = x.size();
std::vector<R_xlen_t> ans(n);
for(R_xlen_t i = 0; i < n; i++){
ans[i] = Rf_xlength(x[i]);
}
return wrap(ans);
}
// [[Rcpp::export]]
Rcpp::IntegerVector rcpp_lengths_works( const List& lst ) {
std::size_t n = lst.size();
Rcpp::IntegerVector res( n );
for(std::size_t i = 0; i < n; i++ ) {
res[i] = Rf_length( lst[i] );
}
return res;
}
// [[Rcpp::export]]
bool lengths_equal(const SEXP& lst){
std::size_t n = Rf_xlength(lst), s, i;
if(n <= 1)
return true;
s = Rf_xlength(VECTOR_ELT(lst, i));
for(i = 1; i < n; i++)
if(Rf_xlength(VECTOR_ELT(lst, i)) != s)
return false;
return true;
}
")
lengths_equal(ll)
replicate(1:4, 10)
replicate(4, 1:10)
replicate(4, 1:10, simplify = FALSE)
lengths_equal(replicate(4, 1:10, simplify = FALSE))
all_equal_length(replicate(4, 1:10, simplify = FALSE))
all_equal_length <- function(x)diff(range(lengths(x))) == 0
all_equal_length(replicate(4, 1:10, simplify = FALSE))
replicate(1e4, 1:2, simplify = FALSE)
lll <- replicate(1e4, 1:2, simplify = FALSE)
microbenchmark(R = all_equal_length(lll),
Rcpp = lengths_equal(lll))
?contains
mtcars[,hello] <- 1:33
mtcars[,"hello"] <- 1:33
mtcars[,"hello"] <- 1:31
rep(4, 1)
`[<-.data.frame`
mtcars[, "hello"] <- list(1:7, 1:20)
mtcars[, "hello"] <- as.data.frame(list(1:7, 1:20))
mtcars[, "hello"] <- as.data.frame(list(1:20, 1:20))
mtcars[,"cyl"] <- 1:4
mtcars
mtcars[,"cyl"] <- 1: 5
mtcars[,"cyl"] <- 1:5
mtcars[,"cyl"] <- 1:22
mtcars[,"cyl"] <- 1:44
mtcars[,3] <- 1:44
mtcars[,3] <- 1:5
browser(`[<-.data.frame`)
q
trace(`[<-.data.frame`, edit = TRUE)
mtcars[,3] <- 1:4
jseq
m
jseq
nvars
dim(mtcars)
mtcars[,12] <- 1:11
length(ew.cols)
length(new.cols)
nvars
jseq > nvars
jseq
nvars
new.cols
nvars
mtcars[,16] <- 1:11
new.cols
library(tidyverse)
select(mtcars, 'ccsc')
select(mtcars, contains('ccsc'))
library(tidyverse)
mtcars2 <- mtcars
newcols <- c("I'm not column", "cyl") # <= one column exist, one does not
for(i in seq_along(newcols)){
mtcars[, ncol(mtcars) + i] <- select(mtcars2, contains(newcols[i]))
}
print(i)
names(mtcars)
dim(mmtcars)
dim(mtcars)
mtcars[, 13] <- mtcars2$cyl
`[.data.frame`
mtcars[, 13] <- "hello world"
nargs
base:::xpdrows.data.frame()
base:::xpdrows.data.frame
?base:::xpdrows.data.frame
subset(mtcars, "hello world")
dplyr::subset(mtcars, "hello world")
tidyr::subset(mtcars, "hello world")
?subset
subset(mtcars, select = 2)
subset(mtcars, select = "hello world")
?contains
subset(mtcars, contains("hello world"))
''
subset(mtcars, cyl == 3)
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i)
for(i in seq_along(unique(mtcars$cyl))){ 
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i)
}
i
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i)
i <- 1
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i)
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i, "mpg")
for(i in seq_along(unique(mtcars$cyl))){ 
mtcars[, ncol(mtcars) + i] <- subset(mtcars, cyl == i, "mpg")
}
subset(mtcars, cyl == i, "mpg")
i
mtcars$cyl
sprintf("hello world %s", "he")
sprintf("hello world %s", 3)
